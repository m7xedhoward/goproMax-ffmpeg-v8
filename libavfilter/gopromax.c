// Generated from libavfilter/opencl/gopromax.cl
const char *ff_source_gopromax_cl =
"#line 1 \"libavfilter/opencl/gopromax.cl\"\n"
"/*\n"
" * Copyright (c) 2021 Ronan LE MEILLAT\n"
" *\n"
" * This file is part of FFmpeg.\n"
" *\n"
" * FFmpeg is free software; you can redistribute it and/or\n"
" * modify it under the terms of the GNU Lesser General Public\n"
" * License as published by the Free Software Foundation; either\n"
" * version 2.1 of the License, or (at your option) any later version.\n"
" *\n"
" * FFmpeg is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
" * Lesser General Public License for more details.\n"
" *\n"
" * You should have received a copy of the GNU Lesser General Public\n"
" * License along with FFmpeg; if not, write to the Free Software\n"
" * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n"
" */\n"
"\n"
"#define OVERLAP 64\n"
"#define CUT 688\n"
"#define BASESIZE 4096 //OVERLAP and CUT are based on this size\n"
"\n"
"\n"
"#define FOV 360.0f\n"
"enum Faces {\n"
"    TOP_LEFT,\n"
"    TOP_MIDDLE,\n"
"    TOP_RIGHT,\n"
"    BOTTOM_LEFT,\n"
"    BOTTOM_MIDDLE,\n"
"    BOTTOM_RIGHT,\n"
"    NB_FACES,\n"
"};\n"
"\n"
"enum Direction {\n"
"    RIGHT,\n"
"    LEFT,\n"
"    UP,\n"
"    DOWN,\n"
"    FRONT,\n"
"    BACK,\n"
"    NB_DIRECTIONS,\n"
"};\n"
"\n"
"enum Rotation {\n"
"    ROT_0,\n"
"    ROT_90,\n"
"    ROT_180,\n"
"    ROT_270,\n"
"    NB_ROTATIONS,\n"
"};\n"
"\n"
"float2 rotate_cube_face(float2 uv, int rotation);\n"
"int2 transpose_gopromax_overlap(int2 xy, int2 dim);\n"
"float3 equirect_to_xyz(int2 xy,int2 size);\n"
"float2 xyz_to_cube(float3 xyz, int *direction, int *face);\n"
"float2 xyz_to_eac(float3 xyz, int2 size);\n"
"\n"
"float2 rotate_cube_face(float2 uv, int rotation)\n"
"{\n"
"    float2 ret_uv;\n"
"\n"
"    switch (rotation) {\n"
"    case ROT_0:\n"
"        ret_uv = uv;\n"
"        break;\n"
"    case ROT_90:\n"
"        ret_uv.x = -uv.y;\n"
"        ret_uv.y =  uv.x;\n"
"        break;\n"
"    case ROT_180:\n"
"        ret_uv.x = -uv.x;\n"
"        ret_uv.y = -uv.y;\n"
"        break;\n"
"    case ROT_270:\n"
"        ret_uv.x =  uv.y;\n"
"        ret_uv.y =  -uv.x;\n"
"        break;\n"
"    }\n"
"return ret_uv;\n"
"}\n"
"\n"
"float3 equirect_to_xyz(int2 xy,int2 size)\n"
"{\n"
"    float3 xyz;\n"
"    float phi   = ((2.f * ((float)xy.x) + 0.5f) / ((float)size.x)  - 1.f) * M_PI_F ;\n"
"    float theta = ((2.f * ((float)xy.y) + 0.5f) / ((float)size.y) - 1.f) * M_PI_2_F;\n"
"\n"
"    xyz.x = cos(theta) * sin(phi);\n"
"    xyz.y = sin(theta);\n"
"    xyz.z = cos(theta) * cos(phi);\n"
"\n"
"    return xyz;\n"
"}\n"
"\n"
"float2 xyz_to_cube(float3 xyz, int *direction, int *face)\n"
"{\n"
"    float phi   = atan2(xyz.x, xyz.z);\n"
"    float theta = asin(xyz.y);\n"
"    float phi_norm, theta_threshold;\n"
"    int face_rotation;\n"
"    float2 uv;\n"
"    //int direction;\n"
"\n"
"    if (phi >= -M_PI_4_F && phi < M_PI_4_F) {\n"
"        *direction = FRONT;\n"
"        phi_norm = phi;\n"
"    } else if (phi >= -(M_PI_2_F + M_PI_4_F) && phi < -M_PI_4_F) {\n"
"        *direction = LEFT;\n"
"        phi_norm = phi + M_PI_2_F;\n"
"    } else if (phi >= M_PI_4_F && phi < M_PI_2_F + M_PI_4_F) {\n"
"        *direction = RIGHT;\n"
"        phi_norm = phi - M_PI_2_F;\n"
"    } else {\n"
"        *direction = BACK;\n"
"        phi_norm = phi + ((phi > 0.f) ? -M_PI_F : M_PI_F);\n"
"    }\n"
"\n"
"    theta_threshold = atan(cos(phi_norm));\n"
"    if (theta > theta_threshold) {\n"
"        *direction = DOWN;\n"
"    } else if (theta < -theta_threshold) {\n"
"        *direction = UP;\n"
"    }\n"
"    \n"
"    theta_threshold = atan(cos(phi_norm));\n"
"    if (theta > theta_threshold) {\n"
"        *direction = DOWN;\n"
"    } else if (theta < -theta_threshold) {\n"
"        *direction = UP;\n"
"    }\n"
"\n"
"    switch (*direction) {\n"
"    case RIGHT:\n"
"        uv.x = -xyz.z / xyz.x;\n"
"        uv.y =  xyz.y / xyz.x;\n"
"        *face = TOP_RIGHT;\n"
"        face_rotation = ROT_0;\n"
"        break;\n"
"    case LEFT:\n"
"        uv.x = -xyz.z / xyz.x;\n"
"        uv.y = -xyz.y / xyz.x;\n"
"        *face = TOP_LEFT;\n"
"        face_rotation = ROT_0;\n"
"        break;\n"
"    case UP:\n"
"        uv.x = -xyz.x / xyz.y;\n"
"        uv.y = -xyz.z / xyz.y;\n"
"        *face = BOTTOM_RIGHT;\n"
"        face_rotation = ROT_270;\n"
"        uv = rotate_cube_face(uv,face_rotation);\n"
"        break;\n"
"    case DOWN:\n"
"        uv.x =  xyz.x / xyz.y;\n"
"        uv.y = -xyz.z / xyz.y;\n"
"        *face = BOTTOM_LEFT;\n"
"        face_rotation = ROT_270;\n"
"        uv = rotate_cube_face(uv,face_rotation);\n"
"        break;\n"
"    case FRONT:\n"
"        uv.x =  xyz.x / xyz.z;\n"
"        uv.y =  xyz.y / xyz.z;\n"
"        *face = TOP_MIDDLE;\n"
"        face_rotation = ROT_0;\n"
"        break;\n"
"    case BACK:\n"
"        uv.x =  xyz.x / xyz.z;\n"
"        uv.y = -xyz.y / xyz.z;\n"
"        *face = BOTTOM_MIDDLE;\n"
"        face_rotation = ROT_90;\n"
"        uv = rotate_cube_face(uv,face_rotation);\n"
"        break;\n"
"    }\n"
"    \n"
"    return uv;\n"
"}\n"
"\n"
"float2 xyz_to_eac(float3 xyz, int2 size)\n"
"{\n"
"    float pixel_pad = 2;\n"
"    float u_pad = pixel_pad / size.x;\n"
"    float v_pad = pixel_pad / size.y;\n"
"\n"
"    int direction, face;\n"
"    int u_face, v_face;\n"
"    float2 uv = xyz_to_cube(xyz,&direction,&face);\n"
"\n"
"    u_face = face % 3;\n"
"    v_face = face / 3;\n"
"    //eac expansion\n"
"    uv.x = M_2_PI_F * atan(uv.x) + 0.5f;\n"
"    uv.y = M_2_PI_F * atan(uv.y) + 0.5f;\n"
"    \n"
"    uv.x = (uv.x + u_face) * (1.f - 2.f * u_pad) / 3.f + u_pad;\n"
"    uv.y = uv.y * (0.5f - 2.f * v_pad) + v_pad + 0.5f * v_face;\n"
"    \n"
"    uv.x *= size.x;\n"
"    uv.y *= size.y;\n"
"\n"
"    return uv;\n"
"}\n"
"\n"
"const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |\n"
"                           CLK_ADDRESS_CLAMP_TO_EDGE   |\n"
"                           CLK_FILTER_NEAREST);\n"
"\n"
"int2 transpose_gopromax_overlap(int2 xy, int2 dim)\n"
"{\n"
"    int2 ret;\n"
"    int cut = dim.x*CUT/BASESIZE;\n"
"    int overlap = dim.x*OVERLAP/BASESIZE;\n"
"    if (xy.x<cut)\n"
"        {\n"
"            ret = xy;\n"
"        }\n"
"    else if ((xy.x>=cut) && (xy.x< (dim.x-cut)))\n"
"        {\n"
"            ret.x = xy.x+overlap;\n"
"            ret.y = xy.y;\n"
"        }\n"
"    else\n"
"        {\n"
"            ret.x = xy.x+2*overlap;\n"
"            ret.y = xy.y;\n"
"        }\n"
"    return ret;\n"
"}\n"
"__kernel void gopromax_equirectangular(__write_only image2d_t dst,\n"
"                             __read_only  image2d_t gopromax_front,\n"
"                             __read_only  image2d_t gopromax_rear)\n"
"{\n"
"    \n"
"    float4 val;\n"
"    int2 loc = (int2)(get_global_id(0), get_global_id(1));\n"
"\n"
"    int2 dst_size = get_image_dim(dst);\n"
"    int2 src_size = get_image_dim(gopromax_front);\n"
"    int2 eac_size = (int2)(src_size.x-2*(src_size.x*OVERLAP/BASESIZE),dst_size.y);\n"
"\n"
"    int half_eight = src_size.y;\n"
"    \n"
"    float3 xyz = equirect_to_xyz(loc,dst_size);\n"
"\n"
"    float2 uv = xyz_to_eac(xyz,eac_size);\n"
"    \n"
"    int2 xy = convert_int2(floor(uv));\n"
"\n"
"    xy = transpose_gopromax_overlap(xy,eac_size);\n"
"    \n"
"    if (xy.y<half_eight)\n"
"        {\n"
"            val = read_imagef(gopromax_front,sampler,xy);\n"
"        }\n"
"    else\n"
"        {\n"
"            val = read_imagef(gopromax_rear,sampler,(int2)(xy.x, (xy.y-half_eight)));\n"
"        }\n"
"\n"
"    write_imagef(dst, loc, val);\n"
"\n"
"}\n"
"\n"
"__kernel void gopromax_stack(__write_only image2d_t dst,\n"
"                             __read_only  image2d_t gopromax_front,\n"
"                             __read_only  image2d_t gopromax_rear)\n"
"{\n"
"    const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |\n"
"                               CLK_ADDRESS_CLAMP_TO_EDGE   |\n"
"                               CLK_FILTER_NEAREST);\n"
"    \n"
"    float4 val;\n"
"    int2 loc = (int2)(get_global_id(0), get_global_id(1));\n"
"    int2 dst_size = get_image_dim(dst);\n"
"    int half_height = dst_size.y / 2;\n"
"    int cut0 = dst_size.x * CUT / (BASESIZE-2*OVERLAP);\n"
"    int cut1 = dst_size.x - cut0;\n"
"    int overlap = dst_size.x * OVERLAP / (BASESIZE-2*OVERLAP);\n"
"    \n"
"    int x;\n"
"    if (loc.x < (cut0-overlap))\n"
"    {\n"
"        x = loc.x;\n"
"    }\n"
"    else if ( (loc.x>=(cut0-overlap)) && ( loc.x < ( cut1 + overlap) ) )\n"
"    {\n"
"        x = loc.x + overlap;\n"
"    }\n"
"    else if ( loc.x >= ( cut1 - 2*overlap) )\n"
"    {\n"
"        x = loc.x + 2*overlap;\n"
"    }\n"
"    \n"
"    if (loc.y < half_height)\n"
"    {\n"
"        val = read_imagef(gopromax_front, sampler, (int2)(x, loc.y));\n"
"    }\n"
"    else\n"
"    {\n"
"        val = read_imagef(gopromax_rear, sampler, (int2)(x, loc.y-half_height));\n"
"    }\n"
"\n"
"        write_imagef(dst, loc, val);\n"
"}\n"
;
